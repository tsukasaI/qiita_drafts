# スタックとヒープについて自分でまとめ直してRustの概念を理解する

Rustを勉強するときにメモリ周りの知識が必要になることを痛感した。

PythonやGoを使っていると、メモリ周りの知識はあまり必要なかった（筆者が気にしていなかった）ためここにまとめていく。

## メモリ領域

プログラムが実行される際には、メモリ領域が必要になる。

メモリ領域は大きく分けて4つあり、それぞれ異なる役割を持つ。

その4つの領域は以下の通り。

### コード領域

    プログラムの実行コードが格納される領域。

### 静的領域

グローバル変数や静的変数が格納される領域。

constで定義された定数もここに格納される。

### スタック領域

関数の呼び出し時に使用される領域。

関数の呼び出し時に引数やローカル変数が格納される。

### ヒープ領域

プログラム実行中に動的に確保される領域。

mallocやnewなどの関数ではここに確保される。

これらメモリ領域のうちコード領域と静的領域はコンパイル時に確定するため、実行時に変更されることはない。

一方で動的に確保されるスタック領域とヒープ領域は実行時に変更されるため、メモリリークやスタックオーバーフローなどの問題が発生する可能性がある。

以上からプログラマが意識すべきはスタック領域とヒープ領域で、本記事ではここにフォーカスする。

## メモリの構成

### スタック

スタックはLIFO（Last In First Out）のデータ構造で、関数の呼び出し時に使用される。

つまり、関数の呼び出し時に引数やローカル変数がスタックに積まれ(push)、関数の終了時にスタックから取り除かれる(pup)。

そのためスタックはデータを取り扱う際に探査が必要ないため、高速にデータのpush/popができる。

逆にいうと、スタックはデータのサイズが固定であるため、動的なメモリ確保ができずサイズが既知で固定されている必要がある。

### ヒープ

ヒープはスタックとは異なり、データのサイズが可変であるため、動的にメモリ確保ができる。

実行時にサイズが不明な場合や、サイズが可変である場合にヒープを使用する。

ヒープはスタックとは異なり、データの探査が必要なためスタックよりも遅い。

## Rustにおけるメモリ管理

これまでのプログラミング言語では、メモリ管理の方法は大きく分けて2つある。

1. 手動でメモリ管理

CやC++などの言語では、メモリの確保や解放をプログラマが明示的に行う必要がある。

malloc, newなどの関数でメモリを確保し、free, deleteなどの関数でメモリを解放する。

メモリの管理をプログラマが行うため、チューニングがしやすい反面、メモリリークやダブルフリーなどの問題が発生する可能性がある。

2. 自動でメモリ管理

JavaやPythonなどの言語では、メモリ管理を自動で行うため、プログラマがメモリ管理を意識する必要がない。

ガーベッジコレクションなどの仕組みにより、メモリリークやダブルフリーなどの問題を回避している一方で、メモリの解放タイミングが不明確になるため、メモリ使用量が増える可能性がある。

Rustは、メモリ管理を自動で行うが、所有権システムを導入することでメモリリークやダブルフリーなどの問題を構造的に回避している。

### 所有権システム

Rustの変数は所有権を持っており、所有者は必ず１つであり、変数がスコープを抜けるときにメモリが解放される。
