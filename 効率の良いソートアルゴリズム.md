効率の良いソートアルゴリズム

# ソートアルゴリズムは効率良くできるか

前回基本ソートアルゴリズムの解説をした。

その時の計算量はO(n ^ 2)であり、基本的には効率は良くない。

ではもっと効率の良いアルゴリズムはあるか。

実際ある。

しかし少し難しくなるのでこの記事で理解を深めてほしい。

## 再帰

ソートアルゴリズムの解説に入る前に再帰の説明をさせてほしい。

この後に紹介するアルゴリズムではこの再帰を用いて効率性を上げている。

さて、再帰とは「あるプロシージャの処理の中でそのプロシージャ自身を呼ぶこと」を指します。

再帰とは、関数が自分自身を呼び出すことを指します。これは、特定の問題をより小さなサブ問題に分割して解決するための強力なプログラミング手法です。再帰は、ループを使用する代わりに、特定のタスクを繰り返し実行するためによく使用されます。

再帰の基本的なパターンは次のとおりです：

基本ケース：再帰の終了条件。これがないと、関数は無限に自分自身を呼び出し続け、スタックオーバーフローを引き起こします。

再帰ケース：関数が自分自身を呼び出すケース。ここでは、問題をより小さなサブ問題に分割します。

以下に、再帰を使用して階乗を計算するPythonのコードを示します：
このコードでは、factorial関数は自分自身を呼び出しています。基本ケースはn == 0で、このときは1を返します。再帰ケースでは、n * factorial(n-1)を返すことで、nの階乗を計算します。

```
def factorial(n):
    # 基本ケース
    if n == 0:
        return 1
    # 再帰ケース
    else:
        return n * factorial(n-1)

print(factorial(5))  # Output: 120
```
