# はじめに

良いコードとはなにかが気になっている人、良いコードを書きたい人、とりあえずどこかのリンクからたどってきた人

いろんなモチベーションがあると思うが良いコードを雰囲気で理解できるレベルまでなってくれることを願う。

# 紹介すること

本記事では**Part 2 実践編**の目次をターゲットにする

~~決してGWにアニメをイッキ見して読み終わったのが昨日だった訳ではない~~

# 比較

```markdown:文章A
ボウルを取る。これをAと呼ぶ。鍋を取る。これをBと呼ぶ。Bを水で満たし、コンロの上に置く。Aにチョコレートとバターを乗せる。前者は100グラム、後者は185グラムにすること。
あとチョコレートはカカオ70%のダークチョコレートにすること。Bの上にAを置く。Aの中身が溶けるまで放置し、BからAを取り除く。新しくボウルを用意する。これをCと呼ぶ。Cに卵、砂糖、バニラエッセンスを入れる。最初のものは2個、2つ目のものは185グラム、3つ目のものはティースプーンの半分にすること。Cの中身を混ぜる。Aの中身が冷めたら、Cに移して混ぜる。新しくボウルを用意する。これをDと呼ぶ。Dに小麦粉、ココアパウダー、食塩を入れる。最初のものは50グラム、2つ目のものは35グラム、3つ目のものはティースプーンの半分にすること。Dの中身を徹底的に混ぜたら、ふるいにかけながらCに入れる。Dの中身が馴染むようによく混ぜる。そういえば、私たちはチョコレートブラウニーを作っているんだけど、いってなかったっけ？Dを取り、70グラムのチョコレートチップを入れ、Dの中身を馴染むようによくかき混ぜる。焼き型を用意する。これをEと呼ぶ。Eにベーキングパウダーを塗って並べる。Dの中身をEに入れる。あなたのオーブンをFと呼ぶ。ちなみに、事前にFを160度で予熱しておかなければならない。EをFに入れて20分待ってから、Eを取り除く。Eを数時間冷やす。
```

```markdown:文章B
チョコレートブラウニーのレシピ
■材料
・バター…100 g
・70%のダークチョコレート…185g
・卵…2個
・バニラエッセンス...小さじ1/2
・グラニュー糖（または上白糖）…185g
・小麦粉…50g
・ココアパウダー…35g
・塩…小さじ1/2
・チョコチップ…70g

作り方
1.オーブンを160°C（320°F）に予熱する
2.油を塗った小さな（6✕6インチ）焼型にベーキングペーパーを敷く
3.ボウルにバターとダークチョコレートを入れ、湯煎して（大きめの鍋のお湯に漬けて）溶かす。溶けたら、湯煎から下して冷ます
4.ボウルに、卵、砂糖、バニラエッセンスを入れて混ぜる
5.卵と砂糖（4.）に、湯煎したバターとダークチョコレート（3.）を加えて混ぜる
6.別のボウルに、小麦粉、ココアパウダー、塩を混ぜ、振るいながら、卵、砂糖、バター、チョコレートの入ったボウル（5.）に入れる。完全に混ざるまで混ぜる
7.チョコチップを加え、ひとまとまりになるまで混ぜる
8.生地（7.）を焼型に入れ、20分間オーブンで焼く
数時間冷まします。
```

下に示したほうがわかりやすかったと思う。

これを良いコード足らしめている部分を目次から持ってきて勝手に見解を述べる

- 5.1 わかりやすい名前を使う
- 5.4 一貫したコーディングスタイルにこだわる
- 5.6 関数の呼び出しを読みやすくする

```
Part 1 理論編

　Chapter 1 コードの品質
　　1.1 コードがソフトウェアになるまで
　　1.2 コードの品質のゴール
　　　1.2.1 正しく動くこと
　　　1.2.2 正しく動作し続けること
　　　1.2.3 要件の変更に対応しやすいこと
　　　1.2.4 車輪の再発明をしないこと
　　1.3 コード品質の柱
　　　1.3.1 コードを読みやすくする
　　　1.3.2 想定外の事態をなくす
　　　1.3.3 誤用しにくいコードを書く
　　　1.3.4 コードをモジュール化する
　　　1.3.5 コードを再利用、汎用化しやすくする
　　　1.3.6 テストしやすいコードを書き、適切にテストする
　　1.4 高品質なコードを書くことは、開発のスピードを遅らせるのか
　　まとめ

　Chapter 2 抽象化レイヤー
　　2.1 擬似コードでのnullの扱い方
　　2.2 なぜ抽象化レイヤーを作るのか
　　　2.2.1 抽象化レイヤーとコード品質の柱
　　2.3 コードのレイヤー
　　　2.3.1 APIと実装の詳細
　　　2.3.2 関数
　　　2.3.3 クラス
　　　2.3.4 インターフェイス
　　　2.3.5 レイヤーが薄すぎるとき
　　2.4 マイクロサービスとは何か
　　まとめ

　Chapter 3 コードでの契約
　　3.1 あなたのコードと他のエンジニアのコード
　　　3.1.1 あなたにとっては明確なことでも、他の人にとっては明確ではない
　　　3.1.2 他のエンジニアは、不注意であなたのコードを壊す
　　　3.1.3 あなたはやがて、あなたのコードのことを忘れる
　　3.2 どうやってあなたのコードの使い方を理解するのか
　　　3.2.1 名前に注目する
　　　3.2.2 データの型に注目する
　　　3.2.3 ドキュメントを読む
　　　3.2.4 直接尋ねる
　　　3.2.5 コードを読む
　　3.3 コードでの契約
　　　3.3.1 契約の中の細則
　　　3.3.2 細かいコメントに頼りすぎない
　　3.4 検査とアサーション
　　　3.4.1 検査
　　　3.4.2 アサーション
　　まとめ

　Chapter 4 エラー
　　4.1 回復可能性
　　　4.1.1 回復可能なエラー
　　　4.1.2 回復不可能なエラー
　　　4.1.3 エラーから回復可能かどうかは、呼び出し元だけが知っている
　　　4.1.4 呼び出し元が回復可能なエラーを呼び出し元に認識させる
　　4.2 堅牢性 vs 失敗
　　　4.2.1 早い失敗
　　　4.2.2 目立つ失敗
　　　4.2.3 回復可能かどうかの範囲
　　　4.2.4 エラーを隠さない
　　4.3 エラーを通知する方法
　　　4.3.1 復習：例外
　　　4.3.2 明示的: 検査例外
　　　4.3.3 暗黙的：非検査例外
　　　4.3.4 明示的：null許容型の戻り値
　　　4.3.5 明示的：Result型の戻り値
　　　4.3.6 明示的：エラーを示す戻り値
　　　4.3.7 暗黙的：Promise型かFuture型
　　　4.3.8 暗黙的：マジックバリューを返す
　　4.4 回復不可能なエラーを通知する
　　4.5 呼び出し元が回復したい可能性のあるエラーを通知する
　　　4.5.1 非検査例外を利用すべきという意見
　　　4.5.2 明示的なテクニックを利用すべきという意見
　　　4.5.3 筆者の意見：明示的なテクニックを使う
　　4.6 コンパイラーの警告を無視しない
　　まとめ

Part 2 実践編

　Chapter 5 コードを読みやすくする
　　5.1 わかりやすい名前を使う
　　　5.1.1 わかりづらい名前は、コードを読みにくくする
　　　5.1.2 コメントは、わかりやすい名前の不適切な代替である
　　　5.1.3 解決策：名前をわかりやすくする
　　5.2 コメントを適切に使う
　　　5.2.1 冗長なコメントは有害である
　　　5.2.2 コメントは、必ずしも読みやすいコードの代わりにはならない
　　　5.2.3 コメントは、コードが存在する理由を説明するのに最適である
　　　5.2.4 コメントは、役立つトップレベルの要約を提供できる
　　5.3 コードの行数にこだわらない
　　　5.3.1 簡潔ではあるものの理解できないコードは避ける
　　　5.3.2 解決策：より多くの行が必要だとしても、コードを読みやすくする
　　5.4 一貫したコーディングスタイルにこだわる
　　　5.4.1 一貫性のないコーディングスタイルは混乱を招くリスクがある
　　　5.4.2 解決策：スタイルガイドを採用して、それに従う
　　5.5 ネストの深いコードは避ける
　　　5.5.1 深くネストしたコードは読みにくい
　　　5.5.2 解決策：ネストを最小限に抑えるようにコードを再構築する
　　　5.5.3 ネストは多くのことをやりすぎている結果である
　　　5.5.4 解決策：コードを小さな関数に分割する
　　5.6 関数の呼び出しを読みやすくする
　　　5.6.1 引数が解読困難な場合がある
　　　5.6.2 解決策：名前付き引数を使用する
　　　5.6.3 解決策：説明的な型を使用する
　　　5.6.4 適切な解決策がない場合もある
　　　5.6.5 IDEはどうだろうか？
　　5.7 説明のない値を使用しない
　　　5.7.1 説明のない値は混乱を招く可能性がある
　　　5.7.2 解決策：適切な名前の定数を使用する
　　　5.7.3 解決策：適切な名前の関数を使用する
　　5.8 無名関数を適切に使用する
　　　5.8.1 無名関数は小さなものへの使用に最適である
　　　5.8.2 無名関数は読みにくい
　　　5.8.3 解決策：代わりに名前付き関数を使用する
　　　5.8.4 巨大な無名関数は問題になる可能性がある
　　　5.8.5 解決策：巨大な無名関数を名前付き関数に分割する
　　5.9 すばらしい新しい言語機能を適切に使用する
　　　5.9.1 新しい機能でコードを改善できる可能性がある
　　　5.9.2 よく知られていない機能は混乱を招く可能性がある
　　　5.9.3 処理に最適なツールを使用する
　　まとめ

　Chapter 6 想定外の事態をなくす
　　6.1 マジックバリューを戻り値に使わない
　　　6.1.1 マジックバリューはバグにつながる可能性がある
　　　6.1.2 解決策：null、オプショナル、エラーを返す
　　　6.1.3 マジックバリューは思いがけず発生することがある
　　6.2 nullオブジェクトパターンを適切に使用する
　　　6.2.1 空のコレクションを返すことでコードが改善することもある
　　　6.2.2 空の文字列を返すと、問題が発生することがある
　　　6.2.3 より複雑なnullオブジェクトは想定外の事態を起こす可能性がある
　　　6.2.4 nullオブジェクトの実装が想定外の事態を起こす可能性がある
　　6.3 予期せぬ副作用の発生を避ける
　　　6.3.1 明白に意図的な副作用は問題ない
　　　6.3.2 予期せぬ副作用は問題になる可能性がある
　　　6.3.3 解決策：副作用を回避するか明白にする
　　6.4 入力パラメーターの変更に注意する
　　　6.4.1 入力パラメーターを変更すると、バグが発生する可能性がある
　　　6.4.2 解決策：変更する前にコピーする
　　6.5 誤解を招くような関数の書き方を避ける
　　　6.5.1 極めて重要な入力値が欠けているときに何もしないと、想定外の事態を起こす可能性がある
　　　6.5.2 解決策：重要な入力値を必須にする
　　6.6 将来的にも有効に使い続けられるように設計された列挙型処理
　　　6.6.1 将来の列挙値を暗黙的に処理すると、問題が発生する可能性がある
　　　6.6.2 解決策：全ケースを網羅したswitch文を使用する
　　　6.6.3 デフォルトケースに注意する
　　　6.6.4 警告：別のプロジェクトの列挙型に依存する
　　6.7 これらのすべてをテストで解決することはできないか？
　　まとめ

　Chapter 7 誤用しにくいコードを書く
　　7.1 すべてを不変にすることを検討する
　　　7.1.1 可変クラスは誤用されやすい
　　　7.1.2 解決策：構築時のみに値を設定する
　　　7.1.3 解決策：不変性を実現するデザインパターンを使用する
　　7.2 すべてを深く不変にすることを検討する
　　　7.2.1 深い可変性は誤用につながる可能性がある
　　　7.2.2 解決策：すべてを防御的にコピーする
　　　7.2.3 解決策：不変のデータ構造を使用する
　　7.3 あまりにも汎用的なデータ型を避ける
　　　7.3.1 あまりにも汎用的な型を使うと、コードを誤用する可能性がある
　　　7.3.2 ペア型は誤用しやすい
　　　7.3.3 解決策：専用の型を使用する
　　7.4 時間の扱い
　　　7.4.1 整数で時刻を表すと、問題が発生する可能性がある
　　　7.4.2 解決策：時間に適切なデータ構造を使用する
　　　7.5 データに対して信頼できる唯一の情報源を持つ
　　7.5.1 2つ目の信頼できる情報源の存在が、不正な状態につながる可能性がある
　　　7.5.2 解決策：一次データを信頼できる唯一の情報源として使用する
　　7.6 ロジックに対する信頼できる唯一の情報源を持つ
　　　7.6.1 ロジックに対する信頼できる情報源が複数あるとバグが発生する可能性がある
　　　7.6.2 解決策：信頼できる唯一の情報源を持つ
　　まとめ

　Chapter 8 コードをモジュール化する
　　8.1 依存性注入（DI）の使用を検討する
　　　8.1.1 ハードコーディングされた依存関係は問題になる可能性がある
　　　8.1.2 解決策：DIを使用する
　　　8.1.3 DIを念頭に置いてコードを設計する
　　8.2 インターフェイスに依存する
　　　8.2.1 具体的な実装に依存することは変更への対応力を制限する
　　　8.2.2 解決策：できる限りインターフェイスに依存する
　　8.3 クラスの継承に注意
　　　8.3.1 クラスの継承は問題になる可能性がある
　　　8.3.2 解決策: コンポジションを使用する
　　　8.3.3 真のis-a関係とは何か?
　　8.4 クラスは自分自身に関心を持つべき
　　　8.4.1 他のクラスに関心を持ちすぎると、問題が起きる可能性がある
　　　8.4.2 解決策：クラスが自分自身に関心を持つようにする
　　8.5 関連データをまとめてカプセル化する
　　　8.5.1 カプセル化していないデータは扱いにくい
　　　8.5.2 解決策：関連データをオブジェクトまたはクラスにグループ化する
　　8.6 戻り値の型から実装の詳細が漏洩することに注意する
　　　8.6.1 戻り値の型から実装の詳細が漏洩すると、問題になる可能性がある
　　　8.6.2 解決策：抽象化レイヤーに適した型を返す
　　8.7 例外の中から実装の詳細が漏洩することに注意する
　　　8.7.1 例外から実装の詳細が漏洩すると、問題が発生する可能性がある
　　　8.7.2 解決策: 例外を抽象化レイヤーに適したものにする
　　まとめ

　Chapter 9 コードを再利用、汎用化しやすくする
　　9.1 想定に注意する
　　　9.1.1 コードを再利用すると、想定がバグにつながる可能性がある
　　　9.1.2 解決策：不必要な想定を避ける
　　　9.1.3 解決策：想定が必要な場合は強制する
　　9.2 グローバル状態に注意する
　　　9.2.1 グローバル状態がコードを安全に再利用できなくする可能性がある
　　　9.2.2 解決策: 共有状態をDIする
　　9.3 デフォルトの戻り値を適切に使用する
　　　9.3.1 下位レイヤーでデフォルトの戻り値を使うと、再利用しづらくなる可能性がある
　　　9.3.2 解決策：より上位レイヤーでデフォルト値を提供する
　　9.4 関数パラメーターの的を絞る
　　　9.4.1 不必要なものを受け取る関数は再利用しづらい
　　　9.4.2 解決策：関数が必要なものだけを受け取るようにする
　　9.5 ジェネリクスの使用を検討する
　　　9.5.1 特定の型に依存すると、汎用性が低くなる
　　　9.5.2 解決策: ジェネリクスを使用する
　　まとめ

　Part 3 ユニットテスト編

　Chapter 10 ユニットテストの原則
　　10.1 ユニットテストの原則
　　10.2 よいユニットテストとは?
　　　10.2.1 破損を正確に検出する
　　　10.2.2 実装の詳細にとらわれない
　　　10.2.3 よく説明された失敗
　　　10.2.4 わかりやすいテストコード
　　　10.2.5 簡単かつ迅速に実行する
　　10.3 パブリックAPIに注目しても重要な動作は無視しない
　　　10.3.1 重要な動作がパブリックAPIの外部にある可能性もある
　　10.4 テストダブル
　　　10.4.1 テストダブルを使用する理由
　　　10.4.2 モック
　　　10.4.3 スタブ
　　　10.4.4 モックとスタブが問題になる可能性がある
　　　10.4.5 フェイク
　　　10.4.6 モックに関する学派
　　10.5 テストのフィロソフィーから選択する
　　まとめ

　Chapter 11 ユニットテストの実践
　　11.1 ただ関数をテストするのではなく動作をテストする
　　　11.1.1 1関数につき1テストケースでは不十分である
　　　11.1.2 解決策: 個々の動作をテストすることに焦点を合わせる
　　11.2 テストのためだけに公開するのは避ける
　　　11.2.1 プライベート関数をテストするのは悪いアイデアである
　　　11.2.2 解決策：パブリックAPI経由のテストを選ぶ
　　　11.2.3 解決策：コードを小さい単位に分ける
　　11.3 一度に1つの動作のみをテストする
　　　11.3.1 一度に複数の動作をテストすると、テストが不十分になる
　　　11.3.2 解決策：それぞれのシナリオごとにテストケースを作る
　　　11.3.3 パラメタライズドテスト
　　11.4 共通のテストのセットアップを適切に使う
　　　11.4.1 状態の共有は問題になる可能性がある
　　　11.4.2 解決策：状態の共有を避けるかリセットする
　　　11.4.3 構成の共有は問題になる可能性がある
　　　11.4.4 解決策：テストケースごとに重要な構成を定義する
　　　11.4.5 いつ構成の共有をするのが適切か
　　11.5 適切なアサーションマッチャーを使う
　　　11.5.1 不適切なマッチャーは失敗の不十分な説明につながる
　　　11.5.2 解決策：適切なアサーションマッチャーを使う
　　11.6 DIを使ってテスタビリティを補強する
　　　11.6.1 ハードコーディングされた依存関係はテストを不可能にする
　　　11.6.2 解決策: DIを利用する
　　　11.7 テストについての最後の言葉
　　まとめ
```

```
1章　理解しやすいコード
    1.1　「優れた」コードって何？
    1.2　読みやすさの基本定理
    1.3　小さなことは絶対にいいこと？
    1.4　「理解するまでにかかる時間」は競合する？
    1.5　でもやるんだよ

第I部　表面上の改善

2章　名前に情報を詰め込む
    2.1　明確な単語を選ぶ
        もっと「カラフル」な単語を探す
    2.2　tmpやretvalなどの汎用的な名前を避ける
        tmp
        ループイテレータ
        汎用的な名前のまとめ
    2.3　抽象的な名前よりも具体的な名前を使う
        例：DISALLOW_EVIL_CONSTRUCTORS
        例：--run_locally
    2.4　名前に情報を追加する
        値の単位
        その他の重要な属性を追加する
    2.5　名前の長さを決める
        スコープが小さければ短い名前でもいい
        長い名前を入力するのは問題じゃない
        頭文字と省略形
        不要な単語を投げ捨てる
    2.6　名前のフォーマットで情報を伝える
        その他のフォーマット規約
    2.7　まとめ

3章　誤解されない名前
    3.1　例：filter()
    3.2　例：Clip(text, length)
    3.3　限界値を含めるときはminとmaxを使う
    3.4　範囲を指定するときはfirstとlastを使う
    3.5　包含／排他的範囲にはbeginとendを使う
    3.6　ブール値の名前
    3.7　ユーザの期待に合わせる
        例：get*()
        例：list::size()
    3.8　例：複数の名前を検討する
    3.9　まとめ

4章　美しさ
    4.1　なぜ美しさが大切なのか？
    4.2　一貫性のある簡潔な改行位置
    4.3　メソッドを使った整列
    4.4　縦の線をまっすぐにする
        整列すべきなのか？
    4.5　一貫性と意味のある並び
    4.6　宣言をブロックにまとめる
    4.7　コードを「段落」に分割する
    4.8　個人的な好みと一貫性
    4.9　まとめ

5章　コメントすべきことを知る
    5.1　コメントするべきでは「ない」こと
        コメントのためのコメントをしない
        ひどい名前はコメントをつけずに名前を変える
    5.2　自分の考えを記録する
        「監督のコメンタリー」を入れる
        コードの欠陥にコメントをつける
        定数にコメントをつける
    5.3　読み手の立場になって考える
        質問されそうなことを想像する
        ハマりそうな罠を告知する
        「全体像」のコメント
        要約コメント
    5.4　ライターズブロックを乗り越える
    5.5　まとめ

6章　コメントは正確で簡潔に
    6.1　コメントを簡潔にしておく
    6.2　あいまいな代名詞を避ける
    6.3　歯切れの悪い文章を磨く
    6.4　関数の動作を正確に記述する
    6.5　入出力のコーナーケースに実例を使う
    6.6　コードの意図を書く
    6.7　「名前付き引数」コメント
    6.8　情報密度の高い言葉を使う
    6.9　まとめ

第II部　ループとロジックの単純化

7章　制御フローを読みやすくする
    7.1　条件式の引数の並び順
    7.2　if/elseブロックの並び順
    7.3　三項演算子
    7.4　do/whileループを避ける
    7.5　関数から早く返す
    7.6　悪名高きgoto
    7.7　ネストを浅くする
        ネストが増える仕組み
        早めに返してネストを削除する
        ループ内部のネストを削除する
    7.8　実行の流れを追えるかい？
    7.9　まとめ

8章　巨大な式を分割する
    8.1　説明変数
    8.2　要約変数
    8.3　ド・モルガンの法則を使う
    8.4　短絡評価の悪用
    8.5　例：複雑なロジックと格闘する
        より優雅な手法を見つける
    8.6　巨大な文を分割する
    8.7　式を簡潔にするもう1つの創造的な方法
    8.8　まとめ

9章　変数と読みやすさ
    9.1　変数を削除する
        役に立たない一時変数
        中間結果を削除する
        制御フロー変数を削除する
    9.2　変数のスコープを縮める
        C++のif文のスコープ
        JavaScriptで「プライベート」変数を作る
        JavaScriptのグローバルスコープ
        PythonとJavaScriptのネストしないスコープ
        定義の位置を下げる
    9.3　変数は一度だけ書き込む
    9.4　最後の例
    9.5　まとめ

第III部　コードの再構成

10章　無関係の下位問題を抽出する
    10.1　入門的な例：findClosestLocation()
    10.2　純粋なユーティリティコード
    10.3　その他の汎用コード
        思いも寄らない恩恵
    10.4　汎用コードをたくさん作る
    10.5　プロジェクトに特化した機能
    10.6　既存のインタフェースを簡潔にする
    10.7　必要に応じてインタフェースを整える
    10.8　やりすぎ
    10.9　まとめ

11章　一度に1つのことを
    11.1　タスクは小さくできる
    11.2　オブジェクトから値を抽出する
        「一度に1つのタスク」を適用する
        その他の手法
    11.3　もっと大きな例
        さらなる改善
    11.4　まとめ

12章　コードに思いを込める
    12.1　ロジックを明確に説明する
    12.2　ライブラリを知る
    12.3　この手法を大きな問題に適用する
        解決策を言葉で説明する
        手法を再帰的に適用する
    12.4　まとめ

13章　短いコードを書く
    13.1　その機能の実装について悩まないで――きっと必要ないから
    13.2　質問と要求の分割
        例：店舗検索システム
        例：キャッシュを追加する
    13.3　コードを小さく保つ
    13.4　身近なライブラリに親しむ
        例：Pythonのリストとセット
        ライブラリの再利用はなぜいいことなのか
    13.5　例：コーディングするよりも
        Unixツールボックスを使う
    13.6　まとめ

第IV部　選抜テーマ

14章　テストと読みやすさ
    14.1　テストを読みやすくて保守しやすいものにする
    14.2　このテストのどこがダメなの？
    14.3　テストを読みやすくする
        最小のテストを作る
        独自の「ミニ言語」を実装する
    14.4　エラーメッセージを読みやすくする
        もっといいassert()を使う
        手作りのエラーメッセージ
    14.5　テストの適切な入力値を選択する
        入力値を単純化する
        1つの機能に複数のテスト
    14.6　テストの機能に名前をつける
    14.7　このテストのどこがダメだったのか？
    14.8　テストに優しい開発
    14.9　やりすぎ
    14.10　まとめ

15章　「分／時間カウンタ」を設計・実装する
    15.1　問題点
    15.2　クラスのインタフェースを定義する
        名前を改善する
        コメントを改善する
    15.3　試案1：素朴な解決策
        このコードは理解しやすいか？
        読みやすいバージョン
        パフォーマンスの問題
    15.4　試案2：ベルトコンベヤー設計
        二段階ベルトコンベヤーの実装
        これで終わり？
    15.5　試案3：時間バケツの設計
        時間バケツの実装
        TrailingBucketCounterを実装する
        ConveyorQueueの実装
    15.6　3つの解決策を比較する
    15.7　まとめ

付録　あわせて読みたい
    高品質のコードを書くための書籍
    プログラミングに関する書籍
    歴史的記録
```
